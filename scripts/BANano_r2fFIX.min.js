function BANano_r2fFIX(t, n, e) {
  var r = e;
  r < n && (r = n), r > n && (n = r);
  let i = +(Math.round(t + "e+" + n) + "e-" + r);
  var o = +i.toFixed(r);
  return o.countDecimals() <= e ? i.toFixed(e) : i.toFixed(r);
}
function NumberFormat2(t, n, e, r, i) {
  return BANano_nf2(BANano_r2fFIX(t, e, r), n, i);
}
function generateUniqueId(len) {
  const alphabet = "abcdefghijklmnopqrstuvwxyz";
  const alphanumeric =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const timestamp = Date.now().toString(36); // Convert timestamp to base 36
  const randomChars = Array.from({ length: len - timestamp.length }, () =>
    alphanumeric.charAt(Math.floor(Math.random() * alphanumeric.length))
  ).join("");
  const firstChar = alphabet.charAt(
    Math.floor(Math.random() * alphabet.length)
  );
  return firstChar + randomChars + timestamp;
};

function isBase64FileString(str) {
  if (typeof str !== 'string' || !str.startsWith('data:')) return false;

  // Strict Data URL pattern: must include a MIME type and base64 indicator
  const dataUrlPattern = /^data:([a-zA-Z0-9!#$&^_+.-]+\/[a-zA-Z0-9!#$&^_+.-]+);base64,([A-Za-z0-9+/]+={0,2})$/;

  const match = str.match(dataUrlPattern);
  if (!match) return false;

  const base64Part = match[2];

  // Final strict validation: ensure decoding works
  try {
    atob(base64Part); // throws if invalid base64
    return true;
  } catch {
    return false;
  }
};

function whatsappToHtml(text) {
  // Escape HTML special characters first
  text = text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");

  // Monospace/code: `text`
  text = text.replace(/`([^`]+?)`/g, "<code>$1</code>");

  // Bold: *text*
  text = text.replace(/\*(\S[^*]*\S|\S)\*/g, "<b>$1</b>");

  // Italic: _text_
  text = text.replace(/_(\S[^_]*\S|\S)_/g, "<i>$1</i>");

  // Strikethrough: ~text~
  text = text.replace(/~(\S[^~]*\S|\S)~/g, "<s>$1</s>");

  // Newlines to <br>
  text = text.replace(/\n/g, "<br>");

  // Unescape HTML entities for the end result
  text = text
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&amp;/g, "&");
  return text;
}
const numberToLetters = (num) => {
  let letters = "";
  while (num >= 0) {
    letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[num % 26] + letters;
    num = Math.floor(num / 26) - 1;
  }
  return letters;
};
function downloadFile(url) {
  const link = document.createElement("a"); // Create an anchor element
  link.href = url; // Set the file URL
  link.download = ""; // Set the download attribute (filename can be optional)
  document.body.appendChild(link); // Append the link to the document
  link.click(); // Programmatically click the link
  document.body.removeChild(link); // Remove the link from the document
}
function paginator(items, page = 1, perPage = 10) {
  const total = items.length;

  // Special case: empty array -> return empty pagination result
  if (total === 0) {
    return {
      currentPage: 0,
      previousPage: 0,
      nextPage: 0,
      hasPreviousPage: false,
      hasNextPage: false,
      total: 0,
      totalPages: 0,
      items: [],
    };
  }

  const totalPages = Math.ceil(total / perPage);
  const currentPage = Math.min(Math.max(page, 1), totalPages);
  const offset = perPage * (currentPage - 1);
  const paginatedItems = items.slice(offset, offset + perPage);

  return {
    currentPage,
    previousPage: currentPage > 1 ? currentPage - 1 : 0,
    nextPage: currentPage < totalPages ? currentPage + 1 : 0,
    hasPreviousPage: currentPage > 1,
    hasNextPage: currentPage < totalPages,
    total,
    totalPages,
    items: paginatedItems,
  };
};

const languages = {
  "am-ET": "Amharic",
  "ar-SA": "Arabic",
  "be-BY": "Bielarus",
  "bem-ZM": "Bemba",
  "bi-VU": "Bislama",
  "bjs-BB": "Bajan",
  "bn-IN": "Bengali",
  "bo-CN": "Tibetan",
  "br-FR": "Breton",
  "bs-BA": "Bosnian",
  "ca-ES": "Catalan",
  "cop-EG": "Coptic",
  "cs-CZ": "Czech",
  "cy-GB": "Welsh",
  "da-DK": "Danish",
  "dz-BT": "Dzongkha",
  "de-DE": "German",
  "dv-MV": "Maldivian",
  "el-GR": "Greek",
  "en-GB": "English",
  "es-ES": "Spanish",
  "et-EE": "Estonian",
  "eu-ES": "Basque",
  "fa-IR": "Persian",
  "fi-FI": "Finnish",
  "fn-FNG": "Fanagalo",
  "fo-FO": "Faroese",
  "fr-FR": "French",
  "gl-ES": "Galician",
  "gu-IN": "Gujarati",
  "ha-NE": "Hausa",
  "he-IL": "Hebrew",
  "hi-IN": "Hindi",
  "hr-HR": "Croatian",
  "hu-HU": "Hungarian",
  "id-ID": "Indonesian",
  "is-IS": "Icelandic",
  "it-IT": "Italian",
  "ja-JP": "Japanese",
  "kk-KZ": "Kazakh",
  "km-KM": "Khmer",
  "kn-IN": "Kannada",
  "ko-KR": "Korean",
  "ku-TR": "Kurdish",
  "ky-KG": "Kyrgyz",
  "la-VA": "Latin",
  "lo-LA": "Lao",
  "lv-LV": "Latvian",
  "men-SL": "Mende",
  "mg-MG": "Malagasy",
  "mi-NZ": "Maori",
  "ms-MY": "Malay",
  "mt-MT": "Maltese",
  "my-MM": "Burmese",
  "ne-NP": "Nepali",
  "niu-NU": "Niuean",
  "nl-NL": "Dutch",
  "no-NO": "Norwegian",
  "ny-MW": "Nyanja",
  "ur-PK": "Pakistani",
  "pau-PW": "Palauan",
  "pa-IN": "Panjabi",
  "ps-PK": "Pashto",
  "pis-SB": "Pijin",
  "pl-PL": "Polish",
  "pt-PT": "Portuguese",
  "rn-BI": "Kirundi",
  "ro-RO": "Romanian",
  "ru-RU": "Russian",
  "sg-CF": "Sango",
  "si-LK": "Sinhala",
  "sk-SK": "Slovak",
  "sm-WS": "Samoan",
  "sn-ZW": "Shona",
  "so-SO": "Somali",
  "sq-AL": "Albanian",
  "sr-RS": "Serbian",
  "sv-SE": "Swedish",
  "sw-SZ": "Swahili",
  "ta-LK": "Tamil",
  "te-IN": "Telugu",
  "tet-TL": "Tetum",
  "tg-TJ": "Tajik",
  "th-TH": "Thai",
  "ti-TI": "Tigrinya",
  "tk-TM": "Turkmen",
  "tl-PH": "Tagalog",
  "tn-BW": "Tswana",
  "to-TO": "Tongan",
  "tr-TR": "Turkish",
  "uk-UA": "Ukrainian",
  "uz-UZ": "Uzbek",
  "vi-VN": "Vietnamese",
  "wo-SN": "Wolof",
  "xh-ZA": "Xhosa",
  "yi-YD": "Yiddish",
  "zu-ZA": "Zulu",
};
function addScript(url) {
  var script = document.createElement("script");
  script.type = "application/javascript";
  script.src = url;
  document.head.appendChild(script);
}
function addScriptAsync(url) {
  var script = document.createElement("script");
  script.type = "application/javascript";
  script.src = url;
  script.async = true;
  script.defer = true;
  document.head.appendChild(script);
}
function addCSS(url) {
  var style = document.createElement("link");
  style.rel = "stylesheet";
  style.type = "text/css";
  style.href = url;
  document.head.appendChild(style);
}
function guid(len) {
  var buf = [],
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    charlen = chars.length,
    length = len || 32;

  for (var i = 0; i < length; i++) {
    buf[i] = chars.charAt(Math.floor(Math.random() * charlen));
  }

  return buf.join("");
}
function nameToHSL(name) {
  let fakeDiv = document.createElement("div");
  fakeDiv.style.color = name;
  document.body.appendChild(fakeDiv);
  let cs = window.getComputedStyle(fakeDiv),
    pv = cs.getPropertyValue("color");
  document.body.removeChild(fakeDiv);
  // Code ripped from RGBToHSL() (except pv is substringed)
  let rgb = pv.substr(4).split(")")[0].split(","),
    r = rgb[0] / 255,
    g = rgb[1] / 255,
    b = rgb[2] / 255,
    cmin = Math.min(r, g, b),
    cmax = Math.max(r, g, b),
    delta = cmax - cmin,
    h = 0,
    s = 0,
    l = 0;
  if (delta == 0) h = 0;
  else if (cmax == r) h = ((g - b) / delta) % 6;
  else if (cmax == g) h = (b - r) / delta + 2;
  else h = (r - g) / delta + 4;
  h = Math.round(h * 60);
  if (h < 0) h += 360;
  l = (cmax + cmin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);
  return "hsl(" + h + "," + s + "%," + l + "%)";
}

function nameToHex(name) {
  // Get RGB from named color in temporary div
  let fakeDiv = document.createElement("div");
  fakeDiv.style.color = name;
  document.body.appendChild(fakeDiv);
  let cs = window.getComputedStyle(fakeDiv),
    pv = cs.getPropertyValue("color");
  document.body.removeChild(fakeDiv);
  // Code ripped from RGBToHex() (except pv is substringed)
  let rgb = pv.substr(4).split(")")[0].split(","),
    r = (+rgb[0]).toString(16),
    g = (+rgb[1]).toString(16),
    b = (+rgb[2]).toString(16);
  if (r.length == 1) r = "0" + r;
  if (g.length == 1) g = "0" + g;
  if (b.length == 1) b = "0" + b;
  return "#" + r + g + b;
}

function hexToHSL(H) {
  // Convert hex to RGB first
  let r = 0,
    g = 0,
    b = 0;
  if (H.length == 4) {
    r = "0x" + H[1] + H[1];
    g = "0x" + H[2] + H[2];
    b = "0x" + H[3] + H[3];
  } else if (H.length == 7) {
    r = "0x" + H[1] + H[2];
    g = "0x" + H[3] + H[4];
    b = "0x" + H[5] + H[6];
  }
  // Then to HSL
  r /= 255;
  g /= 255;
  b /= 255;
  let cmin = Math.min(r, g, b),
    cmax = Math.max(r, g, b),
    delta = cmax - cmin,
    h = 0,
    s = 0,
    l = 0;
  if (delta == 0) h = 0;
  else if (cmax == r) h = ((g - b) / delta) % 6;
  else if (cmax == g) h = (b - r) / delta + 2;
  else h = (r - g) / delta + 4;
  h = Math.round(h * 60);
  if (h < 0) h += 360;
  l = (cmax + cmin) / 2;
  s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = +(s * 100).toFixed(1);
  l = +(l * 100).toFixed(1);
  //return "hsl(" + h + "," + s + "%," + l + "%)";
  return "" + h + "_" + s + "%_" + l + "%";
}
function dataURLToBlob(dataURL) {
  // Code taken from https://github.com/ebidel/filer.js
  var parts = dataURL.split(";base64,");
  var contentType = parts[0].split(":")[1];
  var raw = window.atob(parts[1]);
  var rawLength = raw.length;
  var uInt8Array = new Uint8Array(rawLength);
  for (var i = 0; i < rawLength; ++i) {
    uInt8Array[i] = raw.charCodeAt(i);
  }
  return new Blob([uInt8Array], { type: contentType });
}
// Converts image to canvas; returns new canvas element
function convertImageToCanvas(image) {
  var canvas = document.createElement("canvas");
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext("2d").drawImage(image, 0, 0);
  return canvas;
}
// Converts canvas to an image
function convertCanvasToImage(canvas) {
  var image = new Image();
  image.src = canvas.toDataURL("image/png");
  return image;
}
// Uint8Array to Base64
const convertBitArrtoB64 = (bitArr) =>
  btoa(bitArr.reduce((data, byte) => data + String.fromCharCode(byte), ""));
// Base64 to Uint8Array
const convertB64ToBitArr = (b64Str) =>
  Uint8Array.from(
    atob(b64Str.includes(";base64,") ? b64Str.split(",")[1] : b64Str),
    (v) => v.charCodeAt(0)
  );

function htmlToElement(html) {
  let documentFragment = document.createDocumentFragment();
  let template = document.createElement("template");
  template.innerHTML = html.trim();
  for (let i = 0, e = template.content.childNodes.length; i < e; i++) {
    documentFragment.appendChild(
      template.content.childNodes[i].cloneNode(true)
    );
  }
  return documentFragment;
}
function unixToNormalDate(unixTimestamp) {
  // Convert Unix timestamp from seconds to milliseconds
  const date = new Date(unixTimestamp * 1000);

  // Get individual date components
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0"); // Months are 0-indexed
  const day = String(date.getDate()).padStart(2, "0");

  // Get individual time components
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");

  // Format and return the date string in YYYY-MM-DD HH:MM format
  return `${year}-${month}-${day} ${hours}:${minutes}`;
};

async function getClientIP() {
  const res = await fetch('https://api.ipify.org?format=json');
  const data = await res.json();
  return data.ip;
};
function dataURLtoFile(dataurl, filename) {
    const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
          bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
    for (let i = 0; i < n; i++) u8arr[i] = bstr.charCodeAt(i);
    return new File([u8arr], filename, { type: mime });
};

// Compress Base64 using gzip (pako)
function PakoCompressBase64(base64String) {
    // Convert Base64 string to Uint8Array
    const binaryData = new TextEncoder().encode(base64String);
    // Gzip compress
    const compressed = pako.gzip(binaryData);
    // Convert compressed data to Base64 for storage
    return btoa(String.fromCharCode(...compressed));
};

// Decompress Base64 back to original
function PakoDecompressBase64(compressedBase64) {
    // Decode Base64 back to binary
    const compressedBytes = Uint8Array.from(atob(compressedBase64), c => c.charCodeAt(0));
    // Gzip decompress
    const decompressedData = pako.ungzip(compressedBytes);
    // Convert back to string
    return new TextDecoder().decode(decompressedData);
};
function isBase64Image(str) {
    if (typeof str !== 'string') return false;

    // Regex for data URI with an image MIME type and base64 encoding
    const regex = /^data:image\/(png|jpg|jpeg|gif|webp|bmp|svg\+xml);base64,[A-Za-z0-9+/]+=*$/;

    return regex.test(str);
};
function fileToDataURL(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = error => reject(error);
    reader.readAsDataURL(file);
  });
};
async function getBlackPercentage(base64) {
  return new Promise((resolve) => {
    const img = new Image();
    img.src = base64;
    img.crossOrigin = "Anonymous"; // avoid CORS issues

    img.onload = () => {
      // Draw to canvas
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      const { data } = ctx.getImageData(0, 0, img.width, img.height);

      let blackCount = 0;
      const total = img.width * img.height;

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        // Pure black check
        if (r === 0 && g === 0 && b === 0) {
          blackCount++;
        }
      }

      let percentage = (blackCount / total) * 100;
      percentage.toFixed(2);
      resolve(percentage);
    };
    img.onerror = () => resolve(0); // fallback if image fails
  });
};

function isValidEmail(email) {
  // Regular expression to validate email address format
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  // Test the email string against the regex
  return emailRegex.test(email);
};

function isStrongPassword(password) {
  // Conditions for a strong password:
  // - Minimum 8 characters
  // - At least one lowercase letter
  // - At least one uppercase letter
  // - At least one digit
  // - At least one special character (non-alphanumeric)
  const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[^a-zA-Z0-9]).{8,}$/;
  return strongPasswordRegex.test(password);
};

function isValidUrl(str) {
  const pattern = new RegExp(
    '^([a-zA-Z]+:\\/\\/)?' +               // protocol (optional)
    '((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|' + // domain name
    '((\\d{1,3}\\.){3}\\d{1,3}))' +        // OR IP (v4) address
    '(\\:\\d+)?' +                         // port (optional)
    '(\\/[-a-z\\d%_.~+]*)*' +              // path (optional)
    '(\\?[;&a-z\\d%_.~+=-]*)?' +           // query string (optional)
    '(\\#[-a-z\\d_]*)?$',                   // fragment locator (optional)
    'i'
  );
  return pattern.test(str);
};

function isAlphanumeric(str) {
  // Returns true if str contains only letters and digits, false otherwise
  return /^[a-zA-Z0-9]+$/.test(str);
};

function isNumeric(str) {
  // Returns true if str contains only digits 0-9, false otherwise
  return /^[0-9]+$/.test(str);
}

function rgbaToHexAuto(value) {
    // 1. Check if already HEX format
    const hexPattern = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/;

    if (hexPattern.test(value.trim())) {
        return value.toUpperCase();   // Already HEX, return as-is
    }

    // 2. Otherwise assume RGBA
    const parts = value.replace(/^rgba?\(|\)$/g, "").split(",");
    const r = parseInt(parts[0]);
    const g = parseInt(parts[1]);
    const b = parseInt(parts[2]);
    const a = parseFloat(parts[3]);

    // If alpha = 1 or omitted → return #RRGGBB
    if (!isNaN(a) && a < 1) {
        const alpha = Math.round(a * 255);
        return "#" +
            alpha.toString(16).padStart(2, "0") +
            r.toString(16).padStart(2, "0") +
            g.toString(16).padStart(2, "0") +
            b.toString(16).padStart(2, "0")
        .toUpperCase();
    }

    // No alpha → return #RRGGBB
    return "#" +
        r.toString(16).padStart(2, "0") +
        g.toString(16).padStart(2, "0") +
        b.toString(16).padStart(2, "0")
    .toUpperCase();
}

function hexToRgba(value) {
    const trimmed = value.trim();

    // 1. If already in rgb(...) or rgba(...), return unchanged
    const rgbaPattern = /^rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(,\s*(0|1|0?\.\d+)\s*)?\)$/i;
    if (rgbaPattern.test(trimmed)) {
        return trimmed; // already RGBA, no conversion needed
    }

    // 2. Must be HEX
    let hex = trimmed.replace("#", "");
    
    // Expand shorthand (#RGB or #ARGB)
    if (hex.length === 3) {
        hex = hex.split("").map(h => h + h).join(""); // RGB → RRGGBB
    } else if (hex.length === 4) {
        hex = hex.split("").map(h => h + h).join(""); // ARGB → AARRGGBB
    }

    let r, g, b, a = 255;

    if (hex.length === 6) {
        // RRGGBB
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else if (hex.length === 8) {
        // AARRGGBB
        a = parseInt(hex.substring(0, 2), 16);
        r = parseInt(hex.substring(2, 4), 16);
        g = parseInt(hex.substring(4, 6), 16);
        b = parseInt(hex.substring(6, 8), 16);
    } else {
        throw new Error("Invalid HEX format: " + value);
    }

    const alphaFloat = +(a / 255).toFixed(3);

    return `rgba(${r}, ${g}, ${b}, ${alphaFloat})`;
}
function download(bytes, name) {
  const blob = new Blob([bytes]);
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
}

function setSEO(title, description ) {
      document.title = title;
      document.querySelector('meta[name="description"]').content = description;
    }